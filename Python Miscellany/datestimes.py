# Author:   Matt J Williams
#           http://www.mattjw.net
#           mattjw@mattjw.net
# Date:     2015
# License:  MIT License

"""
Various functions for handling date and time.
"""


def parse_w3c_timedur(duration_str):
    """
    Parse a time duration that is represented in the ISO 8601 format borrowed
    by w3c's XML format.

    This function specifically handles the well-defined duration magntiudes:
    day, hours, minutes, and seconds. ISO 8601 also permits years and months,
    but the duration that these represent is ambiguous.

    Dates in the form "Pn nDTnH nMnS", and variants, are parsed.

    W3C data type spec:
    http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/#duration

    ISO 8601 duration type details:
    http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/#isoformats

    :Returns:
    A timedelta.
    """
    duration_str = duration_str.upper()
    if len(duration_str) == 0:
        raise ValueError("Cannot parse empty string")
    if 'P' not in duration_str:
        raise ValueError("Missing 'P'")
    if ('Y' in duration_str):
        raise ValueError("Years are ambiguous and cannot be parsed")
    if 'T' in duration_str:
        if 'M' in duration_str.split('T')[0]:
            raise ValueError("Months are ambiguous and cannot be parsed")
    if '-' in duration_str:
        raise ValueError("isodate module does not support negative durations (yet)")
    dur = isodate.parse_duration(duration_str)
    assert isinstance(dur, timedelta)
    return dur


def secs_to_str(total_secs):
    """
    Convert a number of seconds `totsecs` (total seconds) to a string.
    The string is formatted in terms of days, hours, minutes, and seconds.
    Fractions of a second are represented by a decimal number of seconds.
    Values are only printed from the leading non-zero denomination.
    
    Examples::

    >>> secs_to_str(0)
    '0.0s'
    >>> secs_to_str(60)
    '1m 0.0s'
    >>> secs_to_str(60*60)
    '1h 0m 0.0s'
    >>> secs_to_str(60*60*24)
    '1d 0h 0m 0.0s'
    >>> secs_to_str(60*60*24+8324.65)
    '1d 2h 18m 44.65s'
    """
    if total_secs < 0:
        raise ValueError("Total seconds (%s) must be 0 or greater" % totsecs)
    denoms = [(24*60*60, 'd'), (60*60, 'h'), (60, 'm')]
    rem = float(total_secs)
    keep = False
    text = ""
    for weight, symb in denoms:
        val = rem // weight
        if val > 0:
            keep = True
        if keep:
            text += "%02d%s " % (val, symb)
        rem = rem % weight
    text += "%06.03fs" % rem
    return text


#
#
# Re: discretisation (bucketing of time)....
#


def dt_floor(dt, magnitude='day'):
    """
    Floor a datetime according to a given magntiude.

    For example,
        dt_floor(datetime(2014, 2, 28, 13, 30), magnitude='day'),
    will return the datetime floored to the lowest day:
        datetime(2014, 2, 28, 0, 0).

    Permitted magnitudes are:
        'year', 'month', 'day', 'hour', 'minute', 'second', 'microsecond'

    :Return:
    The floor of `dt` with respect to magnitude `magnitude`.
    """
    mags = ('year', 'month', 'day', 'hour', 'minute', 'second', 'microsecond')
    subs = ( None,   1,       1,     0,      0,        0,        0)

    if magnitude not in mags:
        raise ValueError("Unknown magnitude '%s'; choose from: %s" % (magnitude, ', '.join(mags)))

    replace_from = mags.index(magnitude)
    for indx in xrange(replace_from+1, len(mags)):
        mag = mags[indx]
        sub = subs[indx]
        arg = {mag: sub}
        dt = dt.replace(**arg)
    return dt


def generate_fixed_bucket_times(min_dt, max_dt, bucket_width):
    """
    Generate a series of equal-duration bucket times. Buckets are separated by
    a duration of `width_td`.

    'Fixed' in this context refers to 'fixing' a continuous time value to its
    nearest discretised bucket time. Buckets begin from 00:00, and
    they evenly divide each hour.

    Bucket times should evenly partition an hour. Mutliples of an hour (even
    more than 24 hours) are also permitted.

    Acts as a generator that yields datetimes. For a given datetime `dt`
    generated by this function, the corresponding bucket represents the 
    half-open interval
        [dt, dt+bucket_width).

    :Params:
    `min_dt`: 
        Datetime. Earliest bucket time. Buckets will start from 00:00 on this 
        date.
    `max_dt`: 
        Datetime. Final bucket will include this time.
    `bucket_width`: 
        Timedelta. Width of bucket.
    
    :Daylight savings:
    Dealing with DST? Best approach is to localise min and max times to UTC
    before using this function.

    :Bucket time construction:
    The bucket times begin at 00:00 on `min_dt`. Buckets times at intervals
    separated by `bucket_width` are then generated until the first bucket
    whose interval includes `max_dt` is produced.
    """
    if ((60*60) % bucket_width.total_seconds()) != 0:
        raise ValueError("bucket width does not evenly divide a day")

    dt = dt_floor(min_dt, 'day')
    while dt <= max_dt:
        yield dt
        dt += bucket_width

def to_fixed_bucket_time(dt, bucket_width):
    """
    'Fix' a continuous time value (datetime `dt`) to its nearest 'fixed' bucket
    time, according to bucket width `bucket_width`.

    Counterpart to `generate_fixed_bucket_times`.
    """
    buck_secs = bucket_width.total_seconds()

    dt_origin = dt_floor(dt, 'day')
    delt_secs = (dt - dt_origin).total_seconds()  #offset into the day

    buck_mult = int(delt_secs // buck_secs)

    fixed_dt = dt_origin + (bucket_width * buck_mult)
    return fixed_dt


if __name__ == "__main__":
    from datetime import datetime, timedelta

    d1 = datetime(2015, 2, 3, 8, 30)
    d2 = datetime(2015, 2, 4)
    width = timedelta(minutes=20)

    bucks = list(generate_fixed_bucket_times(d1, d2, width))
    print "buckets"
    for b in bucks:
        print b
    print "examples..."
    print to_fixed_bucket_time(datetime(2015, 2, 3, 15, 59), width)
